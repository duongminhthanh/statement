import { __rest, __decorate, __metadata } from 'tslib';
import { EventEmitter, ViewChild, ElementRef, Output, Input, Component, ChangeDetectionStrategy, NgZone, NgModule } from '@angular/core';

let ChartjsComponent = class ChartjsComponent {
    constructor(zone) {
        this.zone = zone;
        this.chartClick = new EventEmitter();
        /** chart type */
        this.type = 'doughnut';
        this.height = 150;
        this.width = 300;
        this.legend = {
            display: true,
            position: 'bottom',
        };
        this.options = {};
        this.redraw = false;
        this.datasetKeyProvider = d => d.label;
    }
    ngAfterViewInit() {
        this.renderChart();
    }
    ngOnChanges(changes) {
        if (changes.firstChange) {
            return;
        }
        if (this.chartInstance && this.redraw) {
            this.chartInstance.destroy();
            this.renderChart();
            return;
        }
        this.updateChart();
    }
    updateChart() {
        const data = this.transformData();
        if (!this.chartInstance) {
            return;
        }
        if (this.options) {
            // in order to allow for universal rendering, we import chart.js runtime with `require` to prevent node errors
            const Chart = require('chart.js');
            this.chartInstance.options = Chart.helpers.configMerge(this.chartInstance.options, this.options);
        }
        // Pipe datasets to chart instance datasets enabling
        // seamless transitions
        const currentDatasets = (this.chartInstance.config.data &&
            this.chartInstance.config.data.datasets) ||
            [];
        const nextDatasets = data.datasets || [];
        const currentDatasetsIndexed = {};
        currentDatasets.forEach((x) => {
            currentDatasetsIndexed[this.datasetKeyProvider(x)] = x;
        });
        // We can safely replace the dataset array, as long as we retain the _meta property
        // on each dataset.
        this.chartInstance.config.data.datasets = nextDatasets.map(next => {
            const current = currentDatasetsIndexed[this.datasetKeyProvider(next)];
            if (current && current.type === next.type) {
                // Reassign all properties from next
                for (const nextProp of Object.keys(next)) {
                    // Data array can't be reassigned here.
                    if (nextProp !== 'data') {
                        current[nextProp] = next[nextProp];
                    }
                }
                // Remove properties from current if they was removed in next
                for (const currentProp of Object.keys(current)) {
                    // Be careful with _meta property
                    if (!next.hasOwnProperty(currentProp) && currentProp !== '_meta') {
                        delete current[currentProp];
                    }
                }
                // The data array must be edited in place. As chart.js adds listeners to it.
                current.data.splice(next.data.length);
                next.data.forEach((point, pid) => {
                    current.data[pid] = next.data[pid];
                });
                return current;
            }
            return next;
        });
        const rest = __rest(data, ["datasets"]);
        this.chartInstance.config.data = Object.assign({}, this.chartInstance.config.data, rest);
        this.chartInstance.update();
    }
    renderChart() {
        const node = this.ref.nativeElement;
        const data = this.transformData();
        if (typeof this.legend !== 'undefined') {
            const legendOptions = Object.assign({}, this.legend, this.options.legend);
            this.options.legend = legendOptions;
        }
        // in order to allow for universal rendering, we import Codemirror runtime with `require` to prevent node errors
        const Chart = require('chart.js');
        this.zone.runOutsideAngular(() => {
            this.chartInstance = new Chart(node, {
                type: this.type,
                data,
                options: this.options,
                plugins: this.plugins,
            });
        });
    }
    transformData() {
        if (!this.data) {
            return;
        }
        if (typeof this.data === 'function') {
            const node = this.ref;
            return this.data(node);
        }
        return this.data;
    }
    handleOnClick($event) {
        this.chartClick.emit({
            elements: this.chartInstance.getElementsAtEvent($event),
            element: this.chartInstance.getElementAtEvent($event),
            dataset: this.chartInstance.getDatasetAtEvent($event),
            $event,
        });
    }
};
__decorate([
    ViewChild('ref', { static: true }),
    __metadata("design:type", ElementRef)
], ChartjsComponent.prototype, "ref", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], ChartjsComponent.prototype, "chartClick", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ChartjsComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartjsComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartjsComponent.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartjsComponent.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartjsComponent.prototype, "legend", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartjsComponent.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ChartjsComponent.prototype, "plugins", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartjsComponent.prototype, "redraw", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], ChartjsComponent.prototype, "datasetKeyProvider", void 0);
ChartjsComponent = __decorate([
    Component({
        selector: 'ngx-chartjs',
        template: `
  <!-- wrapping div required for height, width to work -->
  <div>
    <canvas
      #ref
      [attr.height]="height"
      [attr.width]="width"
      (click)="handleOnClick($event)"
    ></canvas>
  </div>
  `,
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [NgZone])
], ChartjsComponent);

let ChartjsModule = class ChartjsModule {
};
ChartjsModule = __decorate([
    NgModule({
        exports: [ChartjsComponent],
        declarations: [ChartjsComponent],
    })
], ChartjsModule);

/**
 * Generated bundle index. Do not edit.
 */

export { ChartjsComponent, ChartjsModule };
//# sourceMappingURL=ctrl-ngx-chartjs.js.map
